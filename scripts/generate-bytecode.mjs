#!/usr/bin/env node

/**
 * generate-bytecode.mjs
 *
 * Compiles Solidity contracts via Foundry and generates TypeScript config files
 * with bytecode, ABI, and verification data for deploy-app.
 *
 * Usage: node scripts/generate-bytecode.mjs
 */

import { execSync } from 'node:child_process';
import { readFileSync, writeFileSync } from 'node:fs';
import { createHash } from 'node:crypto';
import { resolve, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = resolve(__dirname, '..');
const FOUNDRY_TOML = resolve(ROOT, 'foundry.toml');

// EVM config
const EVM_ARTIFACT_PATH = resolve(ROOT, 'out/BulkSend.sol/BulkSend.json');
const EVM_SOURCE_PATH = resolve(ROOT, 'contracts/evm/BulkSend.sol');
const EVM_OUTPUT_PATH = resolve(ROOT, 'deploy-app/src/config/contract.generated.ts');

// Tron config
const TRON_ARTIFACT_PATH = resolve(ROOT, 'out-tron/tron/BulkSend.sol/BulkSend.json');
const TRON_SOURCE_PATH = resolve(ROOT, 'contracts/tron/BulkSend.sol');
const TRON_OUTPUT_PATH = resolve(ROOT, 'deploy-app/src/config/tron-contract.generated.ts');

function run(cmd, opts = {}) {
  try {
    return execSync(cmd, { cwd: ROOT, encoding: 'utf-8', stdio: 'pipe', ...opts }).trim();
  } catch (e) {
    console.error(`Command failed: ${cmd}`);
    console.error(e.stderr || e.message);
    process.exit(1);
  }
}

function checkForge() {
  try {
    execSync('forge --version', { stdio: 'pipe' });
  } catch {
    console.error('Error: forge (Foundry) is not installed or not in PATH.');
    console.error('Install it: curl -L https://foundry.paradigm.xyz | bash && foundryup');
    process.exit(1);
  }
}

function getCompilerVersion() {
  try {
    const toml = readFileSync(FOUNDRY_TOML, 'utf-8');
    const match = toml.match(/solc\s*=\s*"([^"]+)"/);
    return match ? match[1] : 'unknown';
  } catch {
    return 'unknown';
  }
}

function getOptimizerRuns() {
  try {
    const toml = readFileSync(FOUNDRY_TOML, 'utf-8');
    const match = toml.match(/optimizer_runs\s*=\s*(\d+)/);
    return match ? parseInt(match[1], 10) : 200;
  } catch {
    return 200;
  }
}

function sha256(content) {
  return createHash('sha256').update(content).digest('hex');
}

// ---- Generators ----

function generateEVM(solcVersion, optimizerRuns, timestamp) {
  console.log('\n=== EVM Contract ===');
  console.log('Running forge build...');
  run('forge build');

  console.log('Reading build artifact...');
  const artifact = JSON.parse(readFileSync(EVM_ARTIFACT_PATH, 'utf-8'));
  const bytecode = artifact.bytecode.object;
  const abi = artifact.abi;

  if (!bytecode || bytecode === '0x') {
    console.error('Error: EVM bytecode is empty. Build may have failed.');
    process.exit(1);
  }

  console.log('Flattening source for verification...');
  const flattenedSource = run('forge flatten contracts/evm/BulkSend.sol');

  const sourceContent = readFileSync(EVM_SOURCE_PATH, 'utf-8');
  const sourceHash = sha256(sourceContent);

  console.log(`  Bytecode length: ${bytecode.length} chars`);
  console.log(`  ABI entries: ${abi.length}`);
  console.log(`  Source SHA256: ${sourceHash}`);

  const abiString = JSON.stringify(abi, null, 2);

  // Escape backticks and backslashes in flattened source for template literal
  const escapedFlatSource = flattenedSource
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\$/g, '\\$');

  const output = `// AUTO-GENERATED by scripts/generate-bytecode.mjs — DO NOT EDIT MANUALLY
// Source: contracts/evm/BulkSend.sol
// Compiler: solc ${solcVersion}, optimizer ${optimizerRuns} runs
// Generated at: ${timestamp}
// Source SHA256: ${sourceHash}

export const BULK_SEND_BYTECODE = '${bytecode}' as \`0x\${string}\`;

export const BULK_SEND_ABI = ${abiString} as const;

export const BULK_SEND_VERIFY_DATA = {
  sourceCode: \`${escapedFlatSource}\`,
  compilerVersion: 'v${solcVersion}',
  optimizationUsed: true,
  runs: ${optimizerRuns},
  constructorArguments: '',
} as const;
`;

  writeFileSync(EVM_OUTPUT_PATH, output, 'utf-8');
  console.log(`Generated: ${EVM_OUTPUT_PATH}`);
}

function generateTron(solcVersion, optimizerRuns, timestamp) {
  console.log('\n=== Tron Contract ===');
  console.log('Building Tron contract...');
  run('forge build --contracts contracts/tron --out out-tron');

  console.log('Reading build artifact...');
  const artifact = JSON.parse(readFileSync(TRON_ARTIFACT_PATH, 'utf-8'));
  const bytecode = artifact.bytecode.object;
  const abi = artifact.abi;

  if (!bytecode || bytecode === '0x') {
    console.error('Error: Tron bytecode is empty. Build may have failed.');
    process.exit(1);
  }

  const sourceContent = readFileSync(TRON_SOURCE_PATH, 'utf-8');
  const sourceHash = sha256(sourceContent);

  console.log(`  Bytecode length: ${bytecode.length} chars`);
  console.log(`  ABI entries: ${abi.length}`);
  console.log(`  Source SHA256: ${sourceHash}`);

  const abiString = JSON.stringify(abi, null, 2);

  const output = `// AUTO-GENERATED by scripts/generate-bytecode.mjs — DO NOT EDIT MANUALLY
// Source: contracts/tron/BulkSend.sol
// Compiler: solc ${solcVersion}, optimizer ${optimizerRuns} runs
// Generated at: ${timestamp}
// Source SHA256: ${sourceHash}

export const TRON_BULK_SEND_BYTECODE = '${bytecode}';

export const TRON_BULK_SEND_ABI = ${abiString} as const;
`;

  writeFileSync(TRON_OUTPUT_PATH, output, 'utf-8');
  console.log(`Generated: ${TRON_OUTPUT_PATH}`);
}

// ---- Main ----

console.log('Checking forge installation...');
checkForge();

const solcVersion = getCompilerVersion();
const optimizerRuns = getOptimizerRuns();
const timestamp = new Date().toISOString();

console.log(`Compiler: solc ${solcVersion}, optimizer ${optimizerRuns} runs`);

generateEVM(solcVersion, optimizerRuns, timestamp);
generateTron(solcVersion, optimizerRuns, timestamp);

console.log('\nDone.');
