#!/usr/bin/env node

/**
 * generate-bytecode.mjs
 *
 * Compiles Solidity contracts via Foundry and generates TypeScript config files
 * with bytecode, ABI, and verification data for deploy-app.
 *
 * Usage: node scripts/generate-bytecode.mjs
 */

import { execSync } from 'node:child_process';
import { readFileSync, writeFileSync } from 'node:fs';
import { createHash } from 'node:crypto';
import { resolve, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT = resolve(__dirname, '..');
const ARTIFACT_PATH = resolve(ROOT, 'out/BulkSend.sol/BulkSend.json');
const SOURCE_PATH = resolve(ROOT, 'contracts/evm/BulkSend.sol');
const OUTPUT_PATH = resolve(ROOT, 'deploy-app/src/config/contract.generated.ts');
const FOUNDRY_TOML = resolve(ROOT, 'foundry.toml');

function run(cmd, opts = {}) {
  try {
    return execSync(cmd, { cwd: ROOT, encoding: 'utf-8', stdio: 'pipe', ...opts }).trim();
  } catch (e) {
    console.error(`Command failed: ${cmd}`);
    console.error(e.stderr || e.message);
    process.exit(1);
  }
}

function checkForge() {
  try {
    execSync('forge --version', { stdio: 'pipe' });
  } catch {
    console.error('Error: forge (Foundry) is not installed or not in PATH.');
    console.error('Install it: curl -L https://foundry.paradigm.xyz | bash && foundryup');
    process.exit(1);
  }
}

function getCompilerVersion() {
  try {
    const toml = readFileSync(FOUNDRY_TOML, 'utf-8');
    const match = toml.match(/solc\s*=\s*"([^"]+)"/);
    return match ? match[1] : 'unknown';
  } catch {
    return 'unknown';
  }
}

function getOptimizerRuns() {
  try {
    const toml = readFileSync(FOUNDRY_TOML, 'utf-8');
    const match = toml.match(/optimizer_runs\s*=\s*(\d+)/);
    return match ? parseInt(match[1], 10) : 200;
  } catch {
    return 200;
  }
}

function sha256(content) {
  return createHash('sha256').update(content).digest('hex');
}

// ---- Main ----

console.log('Checking forge installation...');
checkForge();

console.log('Running forge build...');
run('forge build');

console.log('Reading build artifact...');
const artifact = JSON.parse(readFileSync(ARTIFACT_PATH, 'utf-8'));
const bytecode = artifact.bytecode.object;
const abi = artifact.abi;

if (!bytecode || bytecode === '0x') {
  console.error('Error: bytecode is empty. Build may have failed.');
  process.exit(1);
}

console.log('Flattening source for verification...');
const flattenedSource = run('forge flatten contracts/evm/BulkSend.sol');

const sourceContent = readFileSync(SOURCE_PATH, 'utf-8');
const sourceHash = sha256(sourceContent);
const solcVersion = getCompilerVersion();
const optimizerRuns = getOptimizerRuns();
const timestamp = new Date().toISOString();

console.log(`  Bytecode length: ${bytecode.length} chars`);
console.log(`  ABI entries: ${abi.length}`);
console.log(`  Source SHA256: ${sourceHash}`);
console.log(`  Compiler: solc ${solcVersion}, optimizer ${optimizerRuns} runs`);

const abiString = JSON.stringify(abi, null, 2);

// Escape backticks and backslashes in flattened source for template literal
const escapedFlatSource = flattenedSource
  .replace(/\\/g, '\\\\')
  .replace(/`/g, '\\`')
  .replace(/\$/g, '\\$');

const output = `// AUTO-GENERATED by scripts/generate-bytecode.mjs â€” DO NOT EDIT MANUALLY
// Source: contracts/evm/BulkSend.sol
// Compiler: solc ${solcVersion}, optimizer ${optimizerRuns} runs
// Generated at: ${timestamp}
// Source SHA256: ${sourceHash}

export const BULK_SEND_BYTECODE = '${bytecode}' as \`0x\${string}\`;

export const BULK_SEND_ABI = ${abiString} as const;

export const BULK_SEND_VERIFY_DATA = {
  sourceCode: \`${escapedFlatSource}\`,
  compilerVersion: 'v${solcVersion}',
  optimizationUsed: true,
  runs: ${optimizerRuns},
  constructorArguments: '',
} as const;
`;

writeFileSync(OUTPUT_PATH, output, 'utf-8');
console.log(`\nGenerated: ${OUTPUT_PATH}`);
console.log('Done.');
