// AUTO-GENERATED by scripts/generate-bytecode.mjs â€” DO NOT EDIT MANUALLY
// Source: contracts/evm/BulkSend.sol
// Compiler: solc 0.8.20, optimizer 200 runs
// Generated at: 2026-02-10T15:42:22.212Z
// Source SHA256: dc0a95aa5fd1f5ba8566bf2120405f993bc0ebbce1282af12f359081991a9da7

export const BULK_SEND_BYTECODE = '0x608060405234801561000f575f80fd5b5061001933610022565b60018055610071565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6125bd8061007e5f395ff3fe60806040526004361061011e575f3560e01c8063950bff9f1161009d578063dced89d311610062578063dced89d31461032a578063f150d7a814610349578063f23a6e611461035c578063f2fde38b14610387578063fc7b0263146103a6575f80fd5b8063950bff9f14610266578063a3beaf6314610289578063bc197c81146102a8578063bc205ad3146102ec578063ca68b6d31461030b575f80fd5b806322985b9e116100e357806322985b9e146101cf57806366775142146101ee578063715018a61461020d57806375ebb90f146102215780638da5cb5b14610240575f80fd5b806301ffc9a7146101295780630ac19e321461015d57806317d678821461017e578063199f67cf1461019d5780631b9207cc146101b0575f80fd5b3661012557005b5f80fd5b348015610134575f80fd5b50610148610143366004611e6e565b6103c5565b60405190151581526020015b60405180910390f35b348015610168575f80fd5b5061017c610177366004611efe565b6103fb565b005b348015610189575f80fd5b5061017c610198366004611f5d565b61060d565b61017c6101ab36600461201b565b610803565b3480156101bb575f80fd5b5061017c6101ca366004612059565b610aa8565b3480156101da575f80fd5b5061017c6101e93660046120a7565b610c21565b3480156101f9575f80fd5b5061017c610208366004612059565b610d09565b348015610218575f80fd5b5061017c610ecd565b34801561022c575f80fd5b5061017c61023b3660046120c0565b610ee0565b34801561024b575f80fd5b505f546040516001600160a01b039091168152602001610154565b348015610271575f80fd5b5061027b6101f481565b604051908152602001610154565b348015610294575f80fd5b5061017c6102a3366004612115565b6110ae565b3480156102b3575f80fd5b506102d36102c236600461226e565b63bc197c8160e01b95945050505050565b6040516001600160e01b03199091168152602001610154565b3480156102f7575f80fd5b5061017c610306366004612310565b6111b9565b348015610316575f80fd5b5061017c6103253660046120c0565b6112d2565b348015610335575f80fd5b5061017c610344366004612341565b611479565b61017c610357366004612380565b61159c565b348015610367575f80fd5b506102d36103763660046123c7565b63f23a6e6160e01b95945050505050565b348015610392575f80fd5b5061017c6103a13660046120a7565b61182a565b3480156103b1575f80fd5b5061017c6103c0366004612059565b6118a8565b5f6001600160e01b03198216630271189760e51b14806103f557506301ffc9a760e01b6001600160e01b03198316145b92915050565b610403611a77565b6001600160a01b03851661042a5760405163d92e233d60e01b815260040160405180910390fd5b825f81900361044c5760405163521299a960e01b815260040160405180910390fd5b6101f481111561046f576040516305beb17160e11b815260040160405180910390fd5b815f0361048f57604051631f2a200560e01b815260040160405180910390fd5b5f5b818110156105fb575f8686838181106104ac576104ac612426565b90506020020160208101906104c191906120a7565b6001600160a01b0316036104e85760405163d92e233d60e01b815260040160405180910390fd5b866001600160a01b031663f242432a3388888581811061050a5761050a612426565b905060200201602081019061051f91906120a7565b87876040518563ffffffff1660e01b8152600401610540949392919061243a565b5f604051808303815f87803b158015610557575f80fd5b505af1158015610569573d5f803e3d5ffd5b5050505085858281811061057f5761057f612426565b905060200201602081019061059491906120a7565b6001600160a01b0316336001600160a01b0316886001600160a01b03167fd0805b1c3c3297e97c7a9457f0c0bffd7e95c846ee2885f60751890e837ba2c887876040516105eb929190918252602082015260400190565b60405180910390a4600101610491565b505061060660018055565b5050505050565b610615611a77565b6001600160a01b03831661063c5760405163d92e233d60e01b815260040160405180910390fd5b805f81900361065e5760405163521299a960e01b815260040160405180910390fd5b6101f4811115610681576040516305beb17160e11b815260040160405180910390fd5b5f5b818110156107f3573684848381811061069e5761069e612426565b6060029190910191505f90506106b760208301836120a7565b6001600160a01b0316036106de5760405163d92e233d60e01b815260040160405180910390fd5b80604001355f0361070257604051631f2a200560e01b815260040160405180910390fd5b6001600160a01b03861663f242432a3361071f60208501856120a7565b846020013585604001356040518563ffffffff1660e01b8152600401610748949392919061243a565b5f604051808303815f87803b15801561075f575f80fd5b505af1158015610771573d5f803e3d5ffd5b506107839250505060208201826120a7565b6001600160a01b0316336001600160a01b0316876001600160a01b03167fd0805b1c3c3297e97c7a9457f0c0bffd7e95c846ee2885f60751890e837ba2c8846020013585604001356040516107e2929190918252602082015260400190565b60405180910390a450600101610683565b50506107fe60018055565b505050565b61080b611a77565b805f81900361082d5760405163521299a960e01b815260040160405180910390fd5b6101f4811115610850576040516305beb17160e11b815260040160405180910390fd5b5f805b828110156108eb573685858381811061086e5761086e612426565b6040029190910191505f905061088760208301836120a7565b6001600160a01b0316036108ae5760405163d92e233d60e01b815260040160405180910390fd5b80602001355f036108d257604051631f2a200560e01b815260040160405180910390fd5b6108e0602082013584612485565b925050600101610853565b508034101561090d5760405163044044a560e21b815260040160405180910390fd5b5f5b82811015610a1c573685858381811061092a5761092a612426565b6040029190910191505f905061094360208301836120a7565b6001600160a01b031682602001356040515f6040518083038185875af1925050503d805f811461098e576040519150601f19603f3d011682016040523d82523d5f602084013e610993565b606091505b50509050806109b5576040516312171d8360e31b815260040160405180910390fd5b6109c260208301836120a7565b6001600160a01b0316336001600160a01b03167f6920ad70d492575b792b7e654d590ec378827834d60329e4103adcd513edd11a8460200135604051610a0a91815260200190565b60405180910390a3505060010161090f565b505f610a288234612498565b90508015610a98576040515f90339083908381818185875af1925050503d805f8114610a6f576040519150601f19603f3d011682016040523d82523d5f602084013e610a74565b606091505b5050905080610a9657604051633c31275160e21b815260040160405180910390fd5b505b505050610aa460018055565b5050565b610ab0611a77565b6001600160a01b038316610ad75760405163d92e233d60e01b815260040160405180910390fd5b805f819003610af95760405163521299a960e01b815260040160405180910390fd5b6101f4811115610b1c576040516305beb17160e11b815260040160405180910390fd5b5f5b818110156107f35736848483818110610b3957610b39612426565b6040029190910191505f9050610b5260208301836120a7565b6001600160a01b031603610b795760405163d92e233d60e01b815260040160405180910390fd5b80602001355f03610b9d57604051631f2a200560e01b815260040160405180910390fd5b610bc433610bae60208401846120a7565b6001600160a01b03891691906020850135611ad0565b610bd160208201826120a7565b6001600160a01b0316336001600160a01b0316876001600160a01b03165f805160206125688339815191528460200135604051610c1091815260200190565b60405180910390a450600101610b1e565b610c29611b3b565b6001600160a01b038116610c505760405163d92e233d60e01b815260040160405180910390fd5b60405147905f906001600160a01b0384169083908381818185875af1925050503d805f8114610c9a576040519150601f19603f3d011682016040523d82523d5f602084013e610c9f565b606091505b5050905080610cc1576040516312171d8360e31b815260040160405180910390fd5b826001600160a01b03167f9296dc35b59a82f89e1de724f3587aaec509b50fa6567c3bd6d4388640f77d7b83604051610cfc91815260200190565b60405180910390a2505050565b610d11611a77565b6001600160a01b038316610d385760405163d92e233d60e01b815260040160405180910390fd5b805f819003610d5a5760405163521299a960e01b815260040160405180910390fd5b6101f4811115610d7d576040516305beb17160e11b815260040160405180910390fd5b5f5b818110156107f35736848483818110610d9a57610d9a612426565b6040029190910191505f9050610db360208301836120a7565b6001600160a01b031603610dda5760405163d92e233d60e01b815260040160405180910390fd5b6001600160a01b0386166323b872dd33610df760208501856120a7565b6040516001600160e01b031960e085901b1681526001600160a01b03928316600482015291166024820152602084013560448201526064015f604051808303815f87803b158015610e46575f80fd5b505af1158015610e58573d5f803e3d5ffd5b50610e6a9250505060208201826120a7565b6001600160a01b0316336001600160a01b0316876001600160a01b03167fe37cb6fd14fca8a04e271082d5b8f54853aa9dfa2f9386ac4878f3d9ca20eb2e8460200135604051610ebc91815260200190565b60405180910390a450600101610d7f565b610ed5611b3b565b610ede5f611b94565b565b610ee8611a77565b6001600160a01b038416610f0f5760405163d92e233d60e01b815260040160405180910390fd5b815f819003610f315760405163521299a960e01b815260040160405180910390fd5b6101f4811115610f54576040516305beb17160e11b815260040160405180910390fd5b815f03610f7457604051631f2a200560e01b815260040160405180910390fd5b5f610f7f83836124ab565b9050610f966001600160a01b038716333084611ad0565b5f5b8281101561109c575f868683818110610fb357610fb3612426565b9050602002016020810190610fc891906120a7565b6001600160a01b031603610fef5760405163d92e233d60e01b815260040160405180910390fd5b61102a86868381811061100457611004612426565b905060200201602081019061101991906120a7565b6001600160a01b0389169086611be3565b85858281811061103c5761103c612426565b905060200201602081019061105191906120a7565b6001600160a01b0316336001600160a01b0316886001600160a01b03165f805160206125688339815191528760405161108c91815260200190565b60405180910390a4600101610f98565b5050506110a860018055565b50505050565b6110b6611b3b565b6001600160a01b0383166110dd5760405163d92e233d60e01b815260040160405180910390fd5b6001600160a01b0382166111045760405163d92e233d60e01b815260040160405180910390fd5b6040516323b872dd60e01b81523060048201526001600160a01b038381166024830152604482018390528416906323b872dd906064015f604051808303815f87803b158015611151575f80fd5b505af1158015611163573d5f803e3d5ffd5b50505050816001600160a01b0316836001600160a01b03167f94417e5316cd2a48d92ca8e57e532134eed3bb7bddd16bf8426e2eae9fb686ec836040516111ac91815260200190565b60405180910390a3505050565b6111c1611b3b565b6001600160a01b0382166111e85760405163d92e233d60e01b815260040160405180910390fd5b6001600160a01b03811661120f5760405163d92e233d60e01b815260040160405180910390fd5b6040516370a0823160e01b81523060048201525f906001600160a01b038416906370a0823190602401602060405180830381865afa158015611253573d5f803e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061127791906124c2565b905061128d6001600160a01b0384168383611be3565b816001600160a01b0316836001600160a01b03167f3d95e1dd133840fdfe95e9a3b6c9fc44f85019531359313e278c6e358ef5b1e0836040516111ac91815260200190565b6112da611a77565b6001600160a01b0384166113015760405163d92e233d60e01b815260040160405180910390fd5b815f8190036113235760405163521299a960e01b815260040160405180910390fd5b6101f4811115611346576040516305beb17160e11b815260040160405180910390fd5b815f0361136657604051631f2a200560e01b815260040160405180910390fd5b5f5b8181101561146e575f85858381811061138357611383612426565b905060200201602081019061139891906120a7565b6001600160a01b0316036113bf5760405163d92e233d60e01b815260040160405180910390fd5b6113fc338686848181106113d5576113d5612426565b90506020020160208101906113ea91906120a7565b6001600160a01b038916919086611ad0565b84848281811061140e5761140e612426565b905060200201602081019061142391906120a7565b6001600160a01b0316336001600160a01b0316876001600160a01b03165f805160206125688339815191528660405161145e91815260200190565b60405180910390a4600101611368565b50506110a860018055565b611481611b3b565b6001600160a01b0384166114a85760405163d92e233d60e01b815260040160405180910390fd5b6001600160a01b0383166114cf5760405163d92e233d60e01b815260040160405180910390fd5b805f036114ef57604051631f2a200560e01b815260040160405180910390fd5b604051637921219560e11b81526001600160a01b0385169063f242432a9061152190309087908790879060040161243a565b5f604051808303815f87803b158015611538575f80fd5b505af115801561154a573d5f803e3d5ffd5b505060408051858152602081018590526001600160a01b038088169450881692507fb97054b292727f1f42e2f5f8ddab9ec6fb8dee1db9765b7a9a110e19e541671a910160405180910390a350505050565b6115a4611a77565b815f8190036115c65760405163521299a960e01b815260040160405180910390fd5b6101f48111156115e9576040516305beb17160e11b815260040160405180910390fd5b815f0361160957604051631f2a200560e01b815260040160405180910390fd5b5f61161483836124ab565b9050803410156116375760405163044044a560e21b815260040160405180910390fd5b5f5b828110156117a2575f86868381811061165457611654612426565b905060200201602081019061166991906120a7565b6001600160a01b0316036116905760405163d92e233d60e01b815260040160405180910390fd5b5f8686838181106116a3576116a3612426565b90506020020160208101906116b891906120a7565b6001600160a01b0316856040515f6040518083038185875af1925050503d805f81146116ff576040519150601f19603f3d011682016040523d82523d5f602084013e611704565b606091505b5050905080611726576040516312171d8360e31b815260040160405180910390fd5b86868381811061173857611738612426565b905060200201602081019061174d91906120a7565b6001600160a01b0316336001600160a01b03167f6920ad70d492575b792b7e654d590ec378827834d60329e4103adcd513edd11a8760405161179191815260200190565b60405180910390a350600101611639565b505f6117ae8234612498565b9050801561181e576040515f90339083908381818185875af1925050503d805f81146117f5576040519150601f19603f3d011682016040523d82523d5f602084013e6117fa565b606091505b505090508061181c57604051633c31275160e21b815260040160405180910390fd5b505b5050506107fe60018055565b611832611b3b565b6001600160a01b03811661189c5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084015b60405180910390fd5b6118a581611b94565b50565b6118b0611a77565b6001600160a01b0383166118d75760405163d92e233d60e01b815260040160405180910390fd5b805f8190036118f95760405163521299a960e01b815260040160405180910390fd5b6101f481111561191c576040516305beb17160e11b815260040160405180910390fd5b5f805b828110156119b7573685858381811061193a5761193a612426565b6040029190910191505f905061195360208301836120a7565b6001600160a01b03160361197a5760405163d92e233d60e01b815260040160405180910390fd5b80602001355f0361199e57604051631f2a200560e01b815260040160405180910390fd5b6119ac602082013584612485565b92505060010161191f565b506119cd6001600160a01b038616333084611ad0565b5f5b8281101561181e57368585838181106119ea576119ea612426565b604002919091019150611a1a9050611a0560208301836120a7565b6001600160a01b038916906020840135611be3565b611a2760208201826120a7565b6001600160a01b0316336001600160a01b0316886001600160a01b03165f805160206125688339815191528460200135604051611a6691815260200190565b60405180910390a4506001016119cf565b600260015403611ac95760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401611893565b6002600155565b6040516001600160a01b03808516602483015283166044820152606481018290526110a89085906323b872dd60e01b906084015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152611c13565b5f546001600160a01b03163314610ede5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401611893565b5f80546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6040516001600160a01b0383166024820152604481018290526107fe90849063a9059cbb60e01b90606401611b04565b5f611c67826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316611ce49092919063ffffffff16565b8051909150156107fe5780806020019051810190611c8591906124d9565b6107fe5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152608401611893565b6060611cf284845f85611cfa565b949350505050565b606082471015611d5b5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401611893565b5f80866001600160a01b03168587604051611d76919061251a565b5f6040518083038185875af1925050503d805f8114611db0576040519150601f19603f3d011682016040523d82523d5f602084013e611db5565b606091505b5091509150611dc687838387611dd1565b979650505050505050565b60608315611e3f5782515f03611e38576001600160a01b0385163b611e385760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401611893565b5081611cf2565b611cf28383815115611e545781518083602001fd5b8060405162461bcd60e51b81526004016118939190612535565b5f60208284031215611e7e575f80fd5b81356001600160e01b031981168114611e95575f80fd5b9392505050565b80356001600160a01b0381168114611eb2575f80fd5b919050565b5f8083601f840112611ec7575f80fd5b5081356001600160401b03811115611edd575f80fd5b6020830191508360208260051b8501011115611ef7575f80fd5b9250929050565b5f805f805f60808688031215611f12575f80fd5b611f1b86611e9c565b945060208601356001600160401b03811115611f35575f80fd5b611f4188828901611eb7565b9699909850959660408101359660609091013595509350505050565b5f805f60408486031215611f6f575f80fd5b611f7884611e9c565b925060208401356001600160401b0380821115611f93575f80fd5b818601915086601f830112611fa6575f80fd5b813581811115611fb4575f80fd5b876020606083028501011115611fc8575f80fd5b6020830194508093505050509250925092565b5f8083601f840112611feb575f80fd5b5081356001600160401b03811115612001575f80fd5b6020830191508360208260061b8501011115611ef7575f80fd5b5f806020838503121561202c575f80fd5b82356001600160401b03811115612041575f80fd5b61204d85828601611fdb565b90969095509350505050565b5f805f6040848603121561206b575f80fd5b61207484611e9c565b925060208401356001600160401b0381111561208e575f80fd5b61209a86828701611fdb565b9497909650939450505050565b5f602082840312156120b7575f80fd5b611e9582611e9c565b5f805f80606085870312156120d3575f80fd5b6120dc85611e9c565b935060208501356001600160401b038111156120f6575f80fd5b61210287828801611eb7565b9598909750949560400135949350505050565b5f805f60608486031215612127575f80fd5b61213084611e9c565b925061213e60208501611e9c565b9150604084013590509250925092565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f191681016001600160401b038111828210171561218a5761218a61214e565b604052919050565b5f82601f8301126121a1575f80fd5b813560206001600160401b038211156121bc576121bc61214e565b8160051b6121cb828201612162565b92835284810182019282810190878511156121e4575f80fd5b83870192505b84831015611dc6578235825291830191908301906121ea565b5f82601f830112612212575f80fd5b81356001600160401b0381111561222b5761222b61214e565b61223e601f8201601f1916602001612162565b818152846020838601011115612252575f80fd5b816020850160208301375f918101602001919091529392505050565b5f805f805f60a08688031215612282575f80fd5b61228b86611e9c565b945061229960208701611e9c565b935060408601356001600160401b03808211156122b4575f80fd5b6122c089838a01612192565b945060608801359150808211156122d5575f80fd5b6122e189838a01612192565b935060808801359150808211156122f6575f80fd5b5061230388828901612203565b9150509295509295909350565b5f8060408385031215612321575f80fd5b61232a83611e9c565b915061233860208401611e9c565b90509250929050565b5f805f8060808587031215612354575f80fd5b61235d85611e9c565b935061236b60208601611e9c565b93969395505050506040820135916060013590565b5f805f60408486031215612392575f80fd5b83356001600160401b038111156123a7575f80fd5b6123b386828701611eb7565b909790965060209590950135949350505050565b5f805f805f60a086880312156123db575f80fd5b6123e486611e9c565b94506123f260208701611e9c565b9350604086013592506060860135915060808601356001600160401b0381111561241a575f80fd5b61230388828901612203565b634e487b7160e01b5f52603260045260245ffd5b6001600160a01b0394851681529290931660208301526040820152606081019190915260a0608082018190525f9082015260c00190565b634e487b7160e01b5f52601160045260245ffd5b808201808211156103f5576103f5612471565b818103818111156103f5576103f5612471565b80820281158282048414176103f5576103f5612471565b5f602082840312156124d2575f80fd5b5051919050565b5f602082840312156124e9575f80fd5b81518015158114611e95575f80fd5b5f5b838110156125125781810151838201526020016124fa565b50505f910152565b5f825161252b8184602087016124f8565b9190910192915050565b602081525f82518060208401526125538160408501602087016124f8565b601f01601f1916919091016040019291505056fea4162acb2096ecf8e81304c656b4ff4eb143f95264f26ac3dad5a3b96bb68b53a26469706673582212202fea630530fa6b12e9491acae837869dfce266696877dec83c13704d6a8747a264736f6c63430008140033' as `0x${string}`;

export const BULK_SEND_ABI = [
  {
    "type": "receive",
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "MAX_BATCH",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "onERC1155BatchReceived",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "",
        "type": "uint256[]",
        "internalType": "uint256[]"
      },
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "onERC1155Received",
    "inputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "owner",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "renounceOwnership",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sendERC1155",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "transfers",
        "type": "tuple[]",
        "internalType": "struct BulkSend.ERC1155Transfer[]",
        "components": [
          {
            "name": "recipient",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "tokenId",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sendERC1155SameToken",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "recipients",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sendERC721",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "transfers",
        "type": "tuple[]",
        "internalType": "struct BulkSend.ERC721Transfer[]",
        "components": [
          {
            "name": "recipient",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "tokenId",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sendNative",
    "inputs": [
      {
        "name": "transfers",
        "type": "tuple[]",
        "internalType": "struct BulkSend.TokenTransfer[]",
        "components": [
          {
            "name": "recipient",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "sendNativeSameAmount",
    "inputs": [
      {
        "name": "recipients",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "sendToken",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "transfers",
        "type": "tuple[]",
        "internalType": "struct BulkSend.TokenTransfer[]",
        "components": [
          {
            "name": "recipient",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sendTokenSameAmount",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "recipients",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sendTokenSameAmountViaContract",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "recipients",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "sendTokenViaContract",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "transfers",
        "type": "tuple[]",
        "internalType": "struct BulkSend.TokenTransfer[]",
        "components": [
          {
            "name": "recipient",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "transferOwnership",
    "inputs": [
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "withdrawStuckERC1155",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "withdrawStuckERC721",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "withdrawStuckNative",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "withdrawStuckToken",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "ERC1155Sent",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ERC721Sent",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NativeSent",
    "inputs": [
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OwnershipTransferred",
    "inputs": [
      {
        "name": "previousOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "newOwner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "StuckERC1155Withdrawn",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "StuckERC721Withdrawn",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "tokenId",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "StuckNativeWithdrawn",
    "inputs": [
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "StuckTokenWithdrawn",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "TokenSent",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "BatchTooLarge",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EmptyArray",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientValue",
    "inputs": []
  },
  {
    "type": "error",
    "name": "RefundFailed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "TransferFailed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAmount",
    "inputs": []
  }
] as const;

export const BULK_SEND_VERIFY_DATA = {
  sourceCode: `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0 ^0.8.1 ^0.8.20;

// lib/openzeppelin-contracts/contracts/utils/Address.sol

// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)

/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if \`account\` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, \`isContract\` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on \`isContract\` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's \`transfer\`: sends \`amount\` wei to
     * \`recipient\`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by \`transfer\`, making them unable to receive funds via
     * \`transfer\`. {sendValue} removes this limitation.
     *
     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to \`recipient\`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level \`call\`. A
     * plain \`call\` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If \`target\` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[\`abi.decode\`].
     *
     * Requirements:
     *
     * - \`target\` must be a contract.
     * - calling \`target\` with \`data\` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[\`functionCall\`], but with
     * \`errorMessage\` as a fallback revert reason when \`target\` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[\`functionCall\`],
     * but also transferring \`value\` wei to \`target\`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least \`value\`.
     * - the called Solidity function must be \`payable\`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[\`functionCallWithValue\`], but
     * with \`errorMessage\` as a fallback revert reason when \`target\` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[\`functionCall\`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[\`functionCall\`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[\`functionCall\`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[\`functionCall\`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
     *
     * _Available since v4.8._
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason or using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}

// lib/openzeppelin-contracts/contracts/utils/Context.sol

// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol

// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * \`interfaceId\`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol

// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when \`value\` tokens are moved from one account (\`from\`) to
     * another (\`to\`).
     *
     * Note that \`value\` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a \`spender\` for an \`owner\` is set by
     * a call to {approve}. \`value\` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by \`account\`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves \`amount\` tokens from the caller's account to \`to\`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that \`spender\` will be
     * allowed to spend on behalf of \`owner\` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets \`amount\` as the allowance of \`spender\` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves \`amount\` tokens from \`from\` to \`to\` using the
     * allowance mechanism. \`amount\` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

// lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol

// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)

/**
 * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 *
 * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 * need to send a transaction, and thus is not required to hold Ether at all.
 */
interface IERC20Permit {
    /**
     * @dev Sets \`value\` as the allowance of \`spender\` over \`\`owner\`\`'s tokens,
     * given \`\`owner\`\`'s signed approval.
     *
     * IMPORTANT: The same issues {IERC20-approve} has related to transaction
     * ordering also apply here.
     *
     * Emits an {Approval} event.
     *
     * Requirements:
     *
     * - \`spender\` cannot be the zero address.
     * - \`deadline\` must be a timestamp in the future.
     * - \`v\`, \`r\` and \`s\` must be a valid \`secp256k1\` signature from \`owner\`
     * over the EIP712-formatted function arguments.
     * - the signature must use \`\`owner\`\`'s current nonce (see {nonces}).
     *
     * For more information on the signature format, see the
     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
     * section].
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    /**
     * @dev Returns the current nonce for \`owner\`. This value must be
     * included whenever a signature is generated for {permit}.
     *
     * Every successful call to {permit} increases \`\`owner\`\`'s nonce by one. This
     * prevents a signature from being used multiple times.
     */
    function nonces(address owner) external view returns (uint256);

    /**
     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
     */
    // solhint-disable-next-line func-name-mixedcase
    function DOMAIN_SEPARATOR() external view returns (bytes32);
}

// lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol

// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from \`ReentrancyGuard\` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single \`nonReentrant\` guard, functions marked as
 * \`nonReentrant\` may not call one another. This can be worked around by making
 * those functions \`private\`, and then adding \`external\` \`nonReentrant\` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    constructor() {
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a \`nonReentrant\` function from another \`nonReentrant\`
     * function is not supported. It is possible to prevent this from happening
     * by making the \`nonReentrant\` function external, and making it call a
     * \`private\` function that does the actual work.
     */
    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        // On the first call to nonReentrant, _status will be _NOT_ENTERED
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");

        // Any calls to nonReentrant after this point will fail
        _status = _ENTERED;
    }

    function _nonReentrantAfter() private {
        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = _NOT_ENTERED;
    }

    /**
     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
     * \`nonReentrant\` function in the call stack.
     */
    function _reentrancyGuardEntered() internal view returns (bool) {
        return _status == _ENTERED;
    }
}

// lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol

// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * \`\`\`solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * \`\`\`
 *
 * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}

// lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155.sol

// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)

/**
 * @dev Required interface of an ERC1155 compliant contract, as defined in the
 * https://eips.ethereum.org/EIPS/eip-1155[EIP].
 *
 * _Available since v3.1._
 */
interface IERC1155 is IERC165 {
    /**
     * @dev Emitted when \`value\` tokens of token type \`id\` are transferred from \`from\` to \`to\` by \`operator\`.
     */
    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);

    /**
     * @dev Equivalent to multiple {TransferSingle} events, where \`operator\`, \`from\` and \`to\` are the same for all
     * transfers.
     */
    event TransferBatch(
        address indexed operator,
        address indexed from,
        address indexed to,
        uint256[] ids,
        uint256[] values
    );

    /**
     * @dev Emitted when \`account\` grants or revokes permission to \`operator\` to transfer their tokens, according to
     * \`approved\`.
     */
    event ApprovalForAll(address indexed account, address indexed operator, bool approved);

    /**
     * @dev Emitted when the URI for token type \`id\` changes to \`value\`, if it is a non-programmatic URI.
     *
     * If an {URI} event was emitted for \`id\`, the standard
     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that \`value\` will equal the value
     * returned by {IERC1155MetadataURI-uri}.
     */
    event URI(string value, uint256 indexed id);

    /**
     * @dev Returns the amount of tokens of token type \`id\` owned by \`account\`.
     *
     * Requirements:
     *
     * - \`account\` cannot be the zero address.
     */
    function balanceOf(address account, uint256 id) external view returns (uint256);

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.
     *
     * Requirements:
     *
     * - \`accounts\` and \`ids\` must have the same length.
     */
    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)
        external
        view
        returns (uint256[] memory);

    /**
     * @dev Grants or revokes permission to \`operator\` to transfer the caller's tokens, according to \`approved\`,
     *
     * Emits an {ApprovalForAll} event.
     *
     * Requirements:
     *
     * - \`operator\` cannot be the caller.
     */
    function setApprovalForAll(address operator, bool approved) external;

    /**
     * @dev Returns true if \`operator\` is approved to transfer \`\`account\`\`'s tokens.
     *
     * See {setApprovalForAll}.
     */
    function isApprovedForAll(address account, address operator) external view returns (bool);

    /**
     * @dev Transfers \`amount\` tokens of token type \`id\` from \`from\` to \`to\`.
     *
     * Emits a {TransferSingle} event.
     *
     * Requirements:
     *
     * - \`to\` cannot be the zero address.
     * - If the caller is not \`from\`, it must have been approved to spend \`\`from\`\`'s tokens via {setApprovalForAll}.
     * - \`from\` must have a balance of tokens of type \`id\` of at least \`amount\`.
     * - If \`to\` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the
     * acceptance magic value.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 id,
        uint256 amount,
        bytes calldata data
    ) external;

    /**
     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.
     *
     * Emits a {TransferBatch} event.
     *
     * Requirements:
     *
     * - \`ids\` and \`amounts\` must have the same length.
     * - If \`to\` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the
     * acceptance magic value.
     */
    function safeBatchTransferFrom(
        address from,
        address to,
        uint256[] calldata ids,
        uint256[] calldata amounts,
        bytes calldata data
    ) external;
}

// lib/openzeppelin-contracts/contracts/token/ERC1155/IERC1155Receiver.sol

// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)

/**
 * @dev _Available since v3.1._
 */
interface IERC1155Receiver is IERC165 {
    /**
     * @dev Handles the receipt of a single ERC1155 token type. This function is
     * called at the end of a \`safeTransferFrom\` after the balance has been updated.
     *
     * NOTE: To accept the transfer, this must return
     * \`bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))\`
     * (i.e. 0xf23a6e61, or its own function selector).
     *
     * @param operator The address which initiated the transfer (i.e. msg.sender)
     * @param from The address which previously owned the token
     * @param id The ID of the token being transferred
     * @param value The amount of tokens being transferred
     * @param data Additional data with no specified format
     * @return \`bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))\` if transfer is allowed
     */
    function onERC1155Received(
        address operator,
        address from,
        uint256 id,
        uint256 value,
        bytes calldata data
    ) external returns (bytes4);

    /**
     * @dev Handles the receipt of a multiple ERC1155 token types. This function
     * is called at the end of a \`safeBatchTransferFrom\` after the balances have
     * been updated.
     *
     * NOTE: To accept the transfer(s), this must return
     * \`bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))\`
     * (i.e. 0xbc197c81, or its own function selector).
     *
     * @param operator The address which initiated the batch transfer (i.e. msg.sender)
     * @param from The address which previously owned the token
     * @param ids An array containing ids of each token being transferred (order and length must match values array)
     * @param values An array containing amounts of each token being transferred (order and length must match ids array)
     * @param data Additional data with no specified format
     * @return \`bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))\` if transfer is allowed
     */
    function onERC1155BatchReceived(
        address operator,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external returns (bytes4);
}

// lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol

// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)

/**
 * @dev Required interface of an ERC721 compliant contract.
 */
interface IERC721 is IERC165 {
    /**
     * @dev Emitted when \`tokenId\` token is transferred from \`from\` to \`to\`.
     */
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);

    /**
     * @dev Emitted when \`owner\` enables \`approved\` to manage the \`tokenId\` token.
     */
    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);

    /**
     * @dev Emitted when \`owner\` enables or disables (\`approved\`) \`operator\` to manage all of its assets.
     */
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);

    /**
     * @dev Returns the number of tokens in \`\`owner\`\`'s account.
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
     * @dev Returns the owner of the \`tokenId\` token.
     *
     * Requirements:
     *
     * - \`tokenId\` must exist.
     */
    function ownerOf(uint256 tokenId) external view returns (address owner);

    /**
     * @dev Safely transfers \`tokenId\` token from \`from\` to \`to\`.
     *
     * Requirements:
     *
     * - \`from\` cannot be the zero address.
     * - \`to\` cannot be the zero address.
     * - \`tokenId\` token must exist and be owned by \`from\`.
     * - If the caller is not \`from\`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     * - If \`to\` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        bytes calldata data
    ) external;

    /**
     * @dev Safely transfers \`tokenId\` token from \`from\` to \`to\`, checking first that contract recipients
     * are aware of the ERC721 protocol to prevent tokens from being forever locked.
     *
     * Requirements:
     *
     * - \`from\` cannot be the zero address.
     * - \`to\` cannot be the zero address.
     * - \`tokenId\` token must exist and be owned by \`from\`.
     * - If the caller is not \`from\`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
     * - If \`to\` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
     *
     * Emits a {Transfer} event.
     */
    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Transfers \`tokenId\` token from \`from\` to \`to\`.
     *
     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
     * understand this adds an external call which potentially creates a reentrancy vulnerability.
     *
     * Requirements:
     *
     * - \`from\` cannot be the zero address.
     * - \`to\` cannot be the zero address.
     * - \`tokenId\` token must be owned by \`from\`.
     * - If the caller is not \`from\`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 tokenId
    ) external;

    /**
     * @dev Gives permission to \`to\` to transfer \`tokenId\` token to another account.
     * The approval is cleared when the token is transferred.
     *
     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
     *
     * Requirements:
     *
     * - The caller must own the token or be an approved operator.
     * - \`tokenId\` must exist.
     *
     * Emits an {Approval} event.
     */
    function approve(address to, uint256 tokenId) external;

    /**
     * @dev Approve or remove \`operator\` as an operator for the caller.
     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
     *
     * Requirements:
     *
     * - The \`operator\` cannot be the caller.
     *
     * Emits an {ApprovalForAll} event.
     */
    function setApprovalForAll(address operator, bool _approved) external;

    /**
     * @dev Returns the account approved for \`tokenId\` token.
     *
     * Requirements:
     *
     * - \`tokenId\` must exist.
     */
    function getApproved(uint256 tokenId) external view returns (address operator);

    /**
     * @dev Returns if the \`operator\` is allowed to manage all of the assets of \`owner\`.
     *
     * See {setApprovalForAll}
     */
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}

// lib/openzeppelin-contracts/contracts/access/Ownable.sol

// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * \`onlyOwner\`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * \`onlyOwner\` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (\`newOwner\`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (\`newOwner\`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Receiver.sol

// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)

/**
 * @dev _Available since v3.1._
 */
abstract contract ERC1155Receiver is ERC165, IERC1155Receiver {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);
    }
}

// lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol

// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a \`using SafeERC20 for IERC20;\` statement to your contract,
 * which allows you to call the safe operations as \`token.safeTransfer(...)\`, etc.
 */
library SafeERC20 {
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender) + value;
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
        }
    }

    function safePermit(
        IERC20Permit token,
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) internal {
        uint256 nonceBefore = token.nonces(owner);
        token.permit(owner, spender, value, deadline, v, r, s);
        uint256 nonceAfter = token.nonces(owner);
        require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            // Return data is optional
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

// lib/openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Holder.sol

// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)

/**
 * Simple implementation of \`ERC1155Receiver\` that will allow a contract to hold ERC1155 tokens.
 *
 * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be
 * stuck.
 *
 * @dev _Available since v3.1._
 */
contract ERC1155Holder is ERC1155Receiver {
    function onERC1155Received(
        address,
        address,
        uint256,
        uint256,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC1155Received.selector;
    }

    function onERC1155BatchReceived(
        address,
        address,
        uint256[] memory,
        uint256[] memory,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC1155BatchReceived.selector;
    }
}

// contracts/evm/BulkSend.sol

contract BulkSend is Ownable, ReentrancyGuard, ERC1155Holder {
    using SafeERC20 for IERC20;

    // 500 recipients * ~38k gas per transfer â‰ˆ 19M gas, safely under 30M block gas limit
    uint256 public constant MAX_BATCH = 500;

    struct TokenTransfer {
        address recipient;
        uint256 amount;
    }

    struct ERC721Transfer {
        address recipient;
        uint256 tokenId;
    }

    struct ERC1155Transfer {
        address recipient;
        uint256 tokenId;
        uint256 amount;
    }

    error EmptyArray();
    error ZeroAddress();
    error ZeroAmount();
    error InsufficientValue();
    error RefundFailed();
    error TransferFailed();
    error BatchTooLarge();

    event NativeSent(address indexed from, address indexed to, uint256 amount);
    event TokenSent(address indexed token, address indexed from, address indexed to, uint256 amount);
    event ERC721Sent(address indexed token, address indexed from, address indexed to, uint256 tokenId);
    event ERC1155Sent(address indexed token, address indexed from, address indexed to, uint256 tokenId, uint256 amount);
    event StuckNativeWithdrawn(address indexed to, uint256 amount);
    event StuckTokenWithdrawn(address indexed token, address indexed to, uint256 amount);
    event StuckERC721Withdrawn(address indexed token, address indexed to, uint256 tokenId);
    event StuckERC1155Withdrawn(address indexed token, address indexed to, uint256 tokenId, uint256 amount);

    function sendNative(TokenTransfer[] calldata transfers) external payable nonReentrant {
        uint256 len = transfers.length;
        if (len == 0) revert EmptyArray();
        if (len > MAX_BATCH) revert BatchTooLarge();

        uint256 total;
        for (uint256 i; i < len;) {
            TokenTransfer calldata t = transfers[i];
            if (t.recipient == address(0)) revert ZeroAddress();
            if (t.amount == 0) revert ZeroAmount();
            total += t.amount;
            unchecked {
                ++i;
            }
        }

        if (msg.value < total) revert InsufficientValue();

        for (uint256 i; i < len;) {
            TokenTransfer calldata t = transfers[i];
            (bool success,) = t.recipient.call{value: t.amount}("");
            if (!success) revert TransferFailed();
            emit NativeSent(msg.sender, t.recipient, t.amount);
            unchecked {
                ++i;
            }
        }

        uint256 remaining = msg.value - total;
        if (remaining > 0) {
            (bool success,) = msg.sender.call{value: remaining}("");
            if (!success) revert RefundFailed();
        }
    }

    function sendNativeSameAmount(address[] calldata recipients, uint256 amount) external payable nonReentrant {
        uint256 len = recipients.length;
        if (len == 0) revert EmptyArray();
        if (len > MAX_BATCH) revert BatchTooLarge();
        if (amount == 0) revert ZeroAmount();

        uint256 total = len * amount;
        if (msg.value < total) revert InsufficientValue();

        for (uint256 i; i < len;) {
            if (recipients[i] == address(0)) revert ZeroAddress();
            (bool success,) = recipients[i].call{value: amount}("");
            if (!success) revert TransferFailed();
            emit NativeSent(msg.sender, recipients[i], amount);
            unchecked {
                ++i;
            }
        }

        uint256 remaining = msg.value - total;
        if (remaining > 0) {
            (bool success,) = msg.sender.call{value: remaining}("");
            if (!success) revert RefundFailed();
        }
    }

    function sendToken(address token, TokenTransfer[] calldata transfers) external nonReentrant {
        if (token == address(0)) revert ZeroAddress();
        uint256 len = transfers.length;
        if (len == 0) revert EmptyArray();
        if (len > MAX_BATCH) revert BatchTooLarge();

        for (uint256 i; i < len;) {
            TokenTransfer calldata t = transfers[i];
            if (t.recipient == address(0)) revert ZeroAddress();
            if (t.amount == 0) revert ZeroAmount();
            IERC20(token).safeTransferFrom(msg.sender, t.recipient, t.amount);
            emit TokenSent(token, msg.sender, t.recipient, t.amount);
            unchecked {
                ++i;
            }
        }
    }

    function sendTokenSameAmount(address token, address[] calldata recipients, uint256 amount) external nonReentrant {
        if (token == address(0)) revert ZeroAddress();
        uint256 len = recipients.length;
        if (len == 0) revert EmptyArray();
        if (len > MAX_BATCH) revert BatchTooLarge();
        if (amount == 0) revert ZeroAmount();

        for (uint256 i; i < len;) {
            if (recipients[i] == address(0)) revert ZeroAddress();
            IERC20(token).safeTransferFrom(msg.sender, recipients[i], amount);
            emit TokenSent(token, msg.sender, recipients[i], amount);
            unchecked {
                ++i;
            }
        }
    }

    function sendERC721(address token, ERC721Transfer[] calldata transfers) external nonReentrant {
        if (token == address(0)) revert ZeroAddress();
        uint256 len = transfers.length;
        if (len == 0) revert EmptyArray();
        if (len > MAX_BATCH) revert BatchTooLarge();

        for (uint256 i; i < len;) {
            ERC721Transfer calldata t = transfers[i];
            if (t.recipient == address(0)) revert ZeroAddress();
            IERC721(token).transferFrom(msg.sender, t.recipient, t.tokenId);
            emit ERC721Sent(token, msg.sender, t.recipient, t.tokenId);
            unchecked {
                ++i;
            }
        }
    }

    function sendERC1155(address token, ERC1155Transfer[] calldata transfers) external nonReentrant {
        if (token == address(0)) revert ZeroAddress();
        uint256 len = transfers.length;
        if (len == 0) revert EmptyArray();
        if (len > MAX_BATCH) revert BatchTooLarge();

        for (uint256 i; i < len;) {
            ERC1155Transfer calldata t = transfers[i];
            if (t.recipient == address(0)) revert ZeroAddress();
            if (t.amount == 0) revert ZeroAmount();
            IERC1155(token).safeTransferFrom(msg.sender, t.recipient, t.tokenId, t.amount, "");
            emit ERC1155Sent(token, msg.sender, t.recipient, t.tokenId, t.amount);
            unchecked {
                ++i;
            }
        }
    }

    function sendERC1155SameToken(address token, address[] calldata recipients, uint256 tokenId, uint256 amount)
        external
        nonReentrant
    {
        if (token == address(0)) revert ZeroAddress();
        uint256 len = recipients.length;
        if (len == 0) revert EmptyArray();
        if (len > MAX_BATCH) revert BatchTooLarge();
        if (amount == 0) revert ZeroAmount();

        for (uint256 i; i < len;) {
            if (recipients[i] == address(0)) revert ZeroAddress();
            IERC1155(token).safeTransferFrom(msg.sender, recipients[i], tokenId, amount, "");
            emit ERC1155Sent(token, msg.sender, recipients[i], tokenId, amount);
            unchecked {
                ++i;
            }
        }
    }

    function withdrawStuckNative(address to) external onlyOwner {
        if (to == address(0)) revert ZeroAddress();
        uint256 amount = address(this).balance;
        (bool success,) = to.call{value: amount}("");
        if (!success) revert TransferFailed();
        emit StuckNativeWithdrawn(to, amount);
    }

    function withdrawStuckToken(address token, address to) external onlyOwner {
        if (token == address(0)) revert ZeroAddress();
        if (to == address(0)) revert ZeroAddress();
        uint256 amount = IERC20(token).balanceOf(address(this));
        IERC20(token).safeTransfer(to, amount);
        emit StuckTokenWithdrawn(token, to, amount);
    }

    function withdrawStuckERC721(address token, address to, uint256 tokenId) external onlyOwner {
        if (token == address(0)) revert ZeroAddress();
        if (to == address(0)) revert ZeroAddress();
        IERC721(token).transferFrom(address(this), to, tokenId);
        emit StuckERC721Withdrawn(token, to, tokenId);
    }

    function withdrawStuckERC1155(address token, address to, uint256 tokenId, uint256 amount) external onlyOwner {
        if (token == address(0)) revert ZeroAddress();
        if (to == address(0)) revert ZeroAddress();
        if (amount == 0) revert ZeroAmount();
        IERC1155(token).safeTransferFrom(address(this), to, tokenId, amount, "");
        emit StuckERC1155Withdrawn(token, to, tokenId, amount);
    }

    // Gas-optimized ERC20 batch send: transfers tokens to contract first, then distributes
    // Note: Does NOT support fee-on-transfer tokens
    function sendTokenViaContract(address token, TokenTransfer[] calldata transfers) external nonReentrant {
        if (token == address(0)) revert ZeroAddress();
        uint256 len = transfers.length;
        if (len == 0) revert EmptyArray();
        if (len > MAX_BATCH) revert BatchTooLarge();

        uint256 total;
        for (uint256 i; i < len;) {
            TokenTransfer calldata t = transfers[i];
            if (t.recipient == address(0)) revert ZeroAddress();
            if (t.amount == 0) revert ZeroAmount();
            total += t.amount;
            unchecked {
                ++i;
            }
        }

        IERC20(token).safeTransferFrom(msg.sender, address(this), total);

        for (uint256 i; i < len;) {
            TokenTransfer calldata t = transfers[i];
            IERC20(token).safeTransfer(t.recipient, t.amount);
            emit TokenSent(token, msg.sender, t.recipient, t.amount);
            unchecked {
                ++i;
            }
        }
    }

    // Gas-optimized ERC20 batch send with same amount
    // Note: Does NOT support fee-on-transfer tokens
    function sendTokenSameAmountViaContract(address token, address[] calldata recipients, uint256 amount)
        external
        nonReentrant
    {
        if (token == address(0)) revert ZeroAddress();
        uint256 len = recipients.length;
        if (len == 0) revert EmptyArray();
        if (len > MAX_BATCH) revert BatchTooLarge();
        if (amount == 0) revert ZeroAmount();

        uint256 total = len * amount;
        IERC20(token).safeTransferFrom(msg.sender, address(this), total);

        for (uint256 i; i < len;) {
            if (recipients[i] == address(0)) revert ZeroAddress();
            IERC20(token).safeTransfer(recipients[i], amount);
            emit TokenSent(token, msg.sender, recipients[i], amount);
            unchecked {
                ++i;
            }
        }
    }

    receive() external payable {}
}`,
  compilerVersion: 'v0.8.20',
  optimizationUsed: true,
  runs: 200,
  constructorArguments: '',
} as const;
